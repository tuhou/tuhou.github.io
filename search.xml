<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpiderDemo第一题-请求头检查</title>
      <link href="/2026/02/28/SpiderDemo%E7%AC%AC%E4%B8%80%E9%A2%98-%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%A3%80%E6%9F%A5/"/>
      <url>/2026/02/28/SpiderDemo%E7%AC%AC%E4%B8%80%E9%A2%98-%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>刚过完年，祝大家恭喜发财。有小伙伴在尝试spiderdemo<code>https://www.spiderdemo.cn/</code>,看了一下这个应该是比之前的马上爬难多了，从他的名称上来看，和猿人学的很像。</p><p>废话不多说，开始今天的第一题：请求头检测</p><h4 id="1、抓包"><a href="#1、抓包" class="headerlink" title="1、抓包"></a>1、抓包</h4><p><img src="/images/spiderDemo1/image-20260226094103604.png" alt="image-20260226094103604"></p><p>抓包直接显示报错，那就换成charles来看看</p><p><img src="/images/spiderDemo1/image-20260226094220326.png" alt="image-20260226094220326"></p><p>charles里面找到了对应的包，直接拷贝到postman试试，能不能获取到值</p><p><img src="/images/spiderDemo1/image-20260226094349524.png" alt="image-20260226094349524"></p><p><img src="/images/spiderDemo1/image-20260226094526742.png" alt="image-20260226094526742"></p><p>postman也能正常获取到值，但是使用python请求会报错</p><h4 id="2、分析"><a href="#2、分析" class="headerlink" title="2、分析"></a>2、分析</h4><p>从题目明确得知是请求头的问题，如何进一步查看问题所在呢，python代码加上代码，charles抓包对比和正常网页请求时的差异</p><p><img src="/images/spiderDemo1/image-20260226095136821.png" alt="image-20260226095136821"></p><p><img src="/images/spiderDemo1/image-20260226095147299.png" alt="image-20260226095147299"></p><p><img src="/images/spiderDemo1/image-20260226095159082.png" alt="image-20260226095159082"></p><p>能明显看出两次请求的请求头顺序不一致，因此使用OrderedDict来固定请求头的顺序</p><p><img src="/images/spiderDemo1/image-20260226095338446.png" alt="image-20260226095338446"></p><p>可以看到成功获取到结果</p>]]></content>
      
      
      <categories>
          
          <category> JS逆向 </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpiderDemo第二题-加解密调整</title>
      <link href="/2026/02/28/SpiderDemo%E7%AC%AC%E4%BA%8C%E9%A2%98-%E5%8A%A0%E8%A7%A3%E5%AF%86%E8%B0%83%E6%95%B4/"/>
      <url>/2026/02/28/SpiderDemo%E7%AC%AC%E4%BA%8C%E9%A2%98-%E5%8A%A0%E8%A7%A3%E5%AF%86%E8%B0%83%E6%95%B4/</url>
      
        <content type="html"><![CDATA[<p>第二题：加解密挑战</p><h4 id="1、抓包"><a href="#1、抓包" class="headerlink" title="1、抓包"></a>1、抓包</h4><p><img src="/images/spiderDemo2/image-20260226102435192.png" alt="image-20260226102435192"></p><p>若出现这个问题，直接关闭Disable cache就好，当然使用charles去抓包也行</p><p><img src="/images/spiderDemo2/image-20260226102546385.png" alt="image-20260226102546385"></p><p>接口分析，可以看到解密值就是一个sign，timestamp时间戳忽略，从堆栈找，当然全局搜索也行</p><p><img src="/images/spiderDemo2/image-20260226102757894.png" alt="image-20260226102757894"></p><p><img src="/images/spiderDemo2/image-20260226102806888.png" alt="image-20260226102806888"></p><p>很快就找到加密点</p><h4 id="2、加密分析"><a href="#2、加密分析" class="headerlink" title="2、加密分析"></a>2、加密分析</h4><p><img src="/images/spiderDemo2/image-20260226102903956.png" alt="image-20260226102903956"></p><p>看到有md5，查看是不是通用加密</p><p><img src="/images/spiderDemo2/image-20260226102938805.png" alt="image-20260226102938805"></p><p>对不上，直接扣代码，点击函数后跳转到此处</p><p><img src="/images/spiderDemo2/image-20260226103342909.png" alt="image-20260226103342909"></p><p>直接全部扣下来，到新页面调用（拷贝时，关闭格式化）</p><p><img src="/images/spiderDemo2/image-20260226103432678.png" alt="image-20260226103432678"></p><p><img src="/images/spiderDemo2/image-20260226103516972.png" alt="image-20260226103516972"></p><p>调用成功</p><h4 id="3、补环境"><a href="#3、补环境" class="headerlink" title="3、补环境"></a>3、补环境</h4><p>直接导入所有的代码到pycharm中执行，发现有很多报错</p><p><img src="/images/spiderDemo2/image-20260226173245865.png" alt="image-20260226173245865"></p><p>缺啥补啥，或者直接将整段代码给到AI</p><p><img src="/images/spiderDemo2/image-20260226173447488.png" alt="image-20260226173447488"></p><p>可以看到此处是AI的建议，为了看的方便，直接ob解混淆<code>https://deobfuscate.relative.im/</code></p><p><img src="/images/spiderDemo2/image-20260227092431929.png" alt="image-20260227092431929"></p><p>可以看到很多环境检测，用于影响结果的三目表达式，将此处的检测点全部补全就能拿到对应的结果</p><p><img src="/images/spiderDemo2/image-20260227101211041.png" alt="image-20260227101211041"></p><h4 id="4、直接调用"><a href="#4、直接调用" class="headerlink" title="4、直接调用"></a>4、直接调用</h4><p>OB还原后能看到加密位置是加了盐</p><p><img src="/images/spiderDemo2/image-20260227093208402.png" alt="image-20260227093208402"></p><p>直接通过ai改写一个加盐的解密函数</p><p><img src="/images/spiderDemo2/image-20260227093255550.png" alt="image-20260227093255550"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">def sign(s: str) -&gt; str:</span><br><span class="line">    salt_bytes = (</span><br><span class="line">        b&#x27;\xa3\xac\xa1\xa3\x66\x64\x6a\x66&#x27;</span><br><span class="line">        b&#x27;\x2c\x6a\x6b\x67\x66\x6b\x6c&#x27;</span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    data = s.encode(&#x27;utf-8&#x27;) + salt_bytes</span><br><span class="line">    return hashlib.md5(data).hexdigest()</span><br><span class="line"></span><br><span class="line">print(sign(&quot;17720728999692&quot;))</span><br></pre></td></tr></table></figure><p><img src="/images/spiderDemo2/image-20260227093417835.png" alt="image-20260227093417835"></p><p>能看到结果一致</p>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极验滑块第4代逆向分析</title>
      <link href="/2026/02/12/%E6%9E%81%E9%AA%8C%E6%BB%91%E5%9D%97%E7%AC%AC4%E4%BB%A3%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
      <url>/2026/02/12/%E6%9E%81%E9%AA%8C%E6%BB%91%E5%9D%97%E7%AC%AC4%E4%BB%A3%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="极验滑块第4代逆向分析"><a href="#极验滑块第4代逆向分析" class="headerlink" title="极验滑块第4代逆向分析"></a>极验滑块第4代逆向分析</h3><p>网址：<code>aHR0cHM6Ly9ndDQuZ2VldGVzdC5jb20v</code></p><h3 id="作者声明：文章仅供学习交流与参考！严禁用于任何商业与非法用途！否则由此产生的一切后果均与作者无关！如有侵权，请联系作者本人进行删除！"><a href="#作者声明：文章仅供学习交流与参考！严禁用于任何商业与非法用途！否则由此产生的一切后果均与作者无关！如有侵权，请联系作者本人进行删除！" class="headerlink" title="作者声明：文章仅供学习交流与参考！严禁用于任何商业与非法用途！否则由此产生的一切后果均与作者无关！如有侵权，请联系作者本人进行删除！"></a>作者声明：文章仅供学习交流与参考！严禁用于任何商业与非法用途！否则由此产生的一切后果均与作者无关！如有侵权，请联系作者本人进行删除！</h3><h4 id="加密参数分析"><a href="#加密参数分析" class="headerlink" title="加密参数分析"></a>加密参数分析</h4><p>首先请求分析，过滤掉图片请求后找到load（加载）和verify（验证）两个请求，从分析他们的入参和返回值，可发现验证接口只有一个W为加密参数，其他的值都能在load的入参或者返回值找到，因此只需要分析W值生成就好</p><p><img src="/images/gt4/image-20250413182329565.png" alt="image-20250413182329565"></p><p><img src="/images/gt4/image-20250413182421521.png" alt="image-20250413182421521"></p><p><img src="/images/gt4/image-20250413182157638.png" alt="image-20250413182157638"></p><h4 id="找加密点"><a href="#找加密点" class="headerlink" title="找加密点"></a>找加密点</h4><p>我是直接通过搜索process_token找到W的加密位置，你也能直接搜索<code>W:</code>来知道，这个和之前版本的一致</p><p><img src="/images/gt4/image-20250413182914544.png" alt="image-20250413182914544"></p><p>下断点</p><p><img src="/images/gt4/image-20250413183226555.png" alt="image-20250413183226555"></p><p>通过多次请求，可以知道计算W值的函数内变量有（或者说你需要计算的参数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pow_msg</span><br><span class="line">pow_sign</span><br><span class="line">c74d2cb0: &#123;d076: &#x27;9c74&#x27;&#125; 计算得来</span><br><span class="line">passtime 滑动时间</span><br><span class="line">setLeft 滑动距离</span><br><span class="line">userresponse</span><br><span class="line">So89: &quot;1AnD&quot; 请求不同的js会变化，但是可固定 </span><br></pre></td></tr></table></figure><h4 id="1、参数-c74d2cb0-d076-‘9c74’"><a href="#1、参数-c74d2cb0-d076-‘9c74’" class="headerlink" title="1、参数 c74d2cb0: {d076: ‘9c74’}"></a>1、参数 c74d2cb0: {d076: ‘9c74’}</h4><p><img src="/images/gt4/image-20250413211649706.png" alt="image-20250413211649706"></p><p>往上翻，发现此参数就是a，然后a根据i和r计算得出</p><p><img src="/images/gt4/image-20250414004255501.png" alt="image-20250414004255501"></p><p><img src="/images/gt4/image-20250414004311755.png" alt="image-20250414004311755"></p><p><img src="/images/gt4/image-20250414004357127.png" alt="image-20250414004357127"></p><p>可以看到i和r计算和lot和lotRes值有关，直接搜索一下693和652，lot和lotRes生成的地方</p><p><img src="/images/gt4/image-20250414004638578.png" alt="image-20250414004638578"></p><p>可以看到lot的实际赋值与一串字符串有关，刚开始我将这个固定死了（对结果无影响），后来发现直接在前面的一个自执行函数中有赋值，而未知参数So89的值也已经有了</p><p><img src="/images/gt4/image-20250414010135471.png" alt="image-20250414010135471"></p><p>跳转到计算的函数，抠出来后缺啥补啥，大体可以得到这样的目录结构，执行完和目标一致</p><p><img src="/images/gt4/image-20250414084157727.png" alt="image-20250414084157727"></p><p><img src="/images/gt4/image-20250414084228764.png" alt="image-20250414084228764"></p><p>此时新增的键值对已经扣完。</p><h4 id="2、参数pow-msg、pow-sign"><a href="#2、参数pow-msg、pow-sign" class="headerlink" title="2、参数pow_msg、pow_sign"></a>2、参数pow_msg、pow_sign</h4><p>简单看下pow_msg组成</p><p><img src="/images/gt4/image-20250414085142253.png" alt="image-20250414085142253"></p><p><code>1|0|md5|2025-04-14T08:48:05.208562+08:00|54088bb07d2df3c46b79f80300b0abbe|63d16e4da9fc4682aed6b359c796769c||6b6f5fb017bcaaea</code></p><p>可知道这个组成为：时间戳（已知，load返回）+ captcha_id（已知） +  lot_number（已知）+ h （未知）</p><p>直接全局搜pow_msg可以找到pow_msg生成的位置</p><p><img src="/images/gt4/image-20250414173304365.png" alt="image-20250414173304365"></p><p>当然你也可以通过堆栈的方式寻找，但是有点麻烦</p><p>找到h的生成函数，发现和之前的版本一致，一个随机的16位数</p><p><img src="/images/gt4/image-20250414173549553.png" alt="image-20250414173549553"></p><p>此时pow_msg的值已经知道，进一步查看pow_sign的生成发现pow_sign为MD5(pow_msg)</p><p><img src="/images/gt4/image-20250415080610018.png" alt="image-20250415080610018"></p><p><img src="/images/gt4/image-20250415080626219.png" alt="image-20250415080626219"></p><p><img src="/images/gt4/image-20250415080734590.png" alt="image-20250415080734590"></p><p>对比后发现此md5加密未修改</p><p>有关滑块的距离和时间这些就不分析了，此版本没有对轨迹进行加密，只需要判断滑动距离和时间就ok</p><h4 id="3、参数W的生成"><a href="#3、参数W的生成" class="headerlink" title="3、参数W的生成"></a>3、参数W的生成</h4><p><img src="/images/gt4/image-20250415081634269.png" alt="image-20250415081634269"></p><p>断点后进入函数，发现又回到了熟悉的两段拼接，进一步分析两段</p><h5 id="3-1-值的生成"><a href="#3-1-值的生成" class="headerlink" title="3-1 _ 值的生成"></a>3-1 _ 值的生成</h5><p>简要分析，<code>_ᖗᕿᖚᖚ</code> 传入值为随机16位字符，实际就是 new (_ᖀᖈᖙᖗ[_ᖈᕸᕸᖚ(7)])函数加密16位字符</p><p><img src="/images/gt4/image-20250415084022874.png" alt="image-20250415084022874"></p><p><img src="/images/gt4/image-20250415090049228.png" alt="image-20250415090049228"></p><p>后续就是扣代码了，还是通过全局的思想，将此函数通过window全局，方便后面调用</p><p>大体是这样</p><p><img src="/images/gt4/image-20250415085624614.png" alt="image-20250415085624614"></p><p>调用流程需要与chrome步骤保持一致，不然会导致this的指向问题</p><p><img src="/images/gt4/image-20250415090431097.png" alt="image-20250415090431097"></p><p>调用后能正确返回值，验证<code>_</code>的生成</p><p><img src="/images/gt4/image-20250415090631958.png" alt="image-20250415090631958"></p><p><img src="/images/gt4/image-20250415090726838.png" alt="image-20250415090726838"></p><h5 id="3-2-u值的生成"><a href="#3-2-u值的生成" class="headerlink" title="3-2 u值的生成"></a>3-2 u值的生成</h5><p><img src="/images/gt4/image-20250415091006710.png" alt="image-20250415091006710"></p><p>分析得知，u值的加密是函数跟_的加密函数大体一致，不同的是u的生成取的是<code>symmetrical</code>函数</p><p>依然是全局抠出来</p><p><img src="/images/gt4/image-20250415093327130.png" alt="image-20250415093327130"></p><p><img src="/images/gt4/image-20250415093335363.png" alt="image-20250415093335363"></p><p>可以看到是一致的，最后的一步arrayToHex就不扣了。其中需要注意的点，随机的16位字符串保持一致。</p><h4 id="4、验证结果"><a href="#4、验证结果" class="headerlink" title="4、验证结果"></a>4、验证结果</h4><p><img src="/images/gt4/image-20250415094351588.png" alt="image-20250415094351588"></p>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS逆向 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Qexo搭建有后台的静态博客</title>
      <link href="/2026/02/12/Hexo+Qexo%E6%90%AD%E5%BB%BA%E6%9C%89%E5%90%8E%E5%8F%B0%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
      <url>/2026/02/12/Hexo+Qexo%E6%90%AD%E5%BB%BA%E6%9C%89%E5%90%8E%E5%8F%B0%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>一直以来hexo都是我自己比较喜欢的一个静态博客，有很多很漂亮的主题。但是对于静态博客来说，很不好的一点是不能直接后台管理，直接上传文章这类。刚好最近看到了一个Qexo静态博客编辑器。地址：<code>https://oplog.cn/qexo/start.html</code>现在重新改一改我的网站tuhouni.cn，已经放着1年多吃灰了。</p><h4 id="一：我的环境"><a href="#一：我的环境" class="headerlink" title="一：我的环境"></a>一：我的环境</h4><p>本地虚拟机搭建hexo、仓库为github、Qexo在本地虚拟机上（为什么不在云服务上，个人习惯）、图床（云服务器）</p><h4 id="二：环境搭建"><a href="#二：环境搭建" class="headerlink" title="二：环境搭建"></a>二：环境搭建</h4><p>环境：ubuntu20.0.4</p><p>首先安装npm</p><p>apt update</p><p>apt install npm</p><p>此时node版本太低，需要升级</p><p>安装nvm</p><p><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</code></p><p>生效</p><p><code>source ~/.bashrc</code></p><p>安装指定node版本</p><p>nvm install 24.0.0</p><p>安装宝塔：<code>wget -O install_panel.sh https://download.bt.cn/install/install_panel.sh &amp;&amp; sudo bash install_panel.sh ssl251104</code></p><p>本文章分为三部分：hexo搭建、主题优化、qexo搭建</p><h4 id="1、hexo搭建"><a href="#1、hexo搭建" class="headerlink" title="1、hexo搭建"></a>1、hexo搭建</h4><p>安装cnpm管理器</p><p><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></p><p>安装hexo框架</p><p><code>cnpm install -g hexo-cli</code></p><p>初始化</p><p><code>hexo init blog</code></p><p>进入项目启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">cnpm install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/images/qexo/image-20260202093656488.png" alt="image-20260202093656488"></p><p>出现这个报错：升级npm</p><h4 id="2、主题优化"><a href="#2、主题优化" class="headerlink" title="2、主题优化"></a>2、主题优化</h4><p>主题下载 <code>git clone -b dev https://github.com/everfu/hexo-theme-solitude.git themes/solitude</code></p><p>修改主题： theme: solitude</p><p>安装依赖：<code>npm i hexo-renderer-pug</code></p><h4 id="3、Qexo搭建"><a href="#3、Qexo搭建" class="headerlink" title="3、Qexo搭建"></a>3、Qexo搭建</h4><p>官网：<code>https://oplog.cn/qexo/</code></p><p>我选择的是源码搭建，在宝塔面板上搭建，在你喜欢的位置把文件上传上</p><p><img src="/images/qexo/image-20260209215908587.png" alt="image-20260209215908587"></p><p>创建一个configs.py，根据自己的数据库创建写对应的连接方式，我用的是mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line">DOMAINS = [&#x27;127.0.0.1&#x27;,&#x27;0.0.0.0&#x27;]</span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">            &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">            &#x27;NAME&#x27;: &#x27;xxx&#x27;,</span><br><span class="line">            &#x27;USER&#x27;: &#x27;xxx&#x27;,</span><br><span class="line">            &#x27;PASSWORD&#x27;: &#x27;xxxx&#x27;,</span><br><span class="line">            &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">            &#x27;PORT&#x27;: &#x27;3306&#x27;,</span><br><span class="line">            &#x27;OPTIONS&#x27;: &#123;</span><br><span class="line">                &quot;init_command&quot;: &quot;SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/qexo/image-20260209220052738.png" alt="image-20260209220052738"></p><p>连接数据库有安装依赖python和依赖包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt install python3-pip</span><br><span class="line">pip3 install -r requirements.txt</span><br><span class="line">python3 manage.py makemigrations</span><br><span class="line">python3 manage.py migrate</span><br><span class="line">python3 manage.py runserver 0.0.0.0:8000 --noreload</span><br></pre></td></tr></table></figure><p>登录后进行设置，我的是虚拟机本机，选择本地，路径根据自己的地址设置。自动部署的位置需要修改</p><p><img src="/images/qexo/image-20260209220223932.png" alt="image-20260209220223932"></p><p>此时保存后进行发文测试，显示成功，但是在public文章中没有对应的文章，查看日志中发现报错</p><p><img src="/images/qexo/image-20260209220842173.png" alt="image-20260209220842173"></p><p>提示找不到hexo，直接使用路径调用</p><p><img src="/images/qexo/image-20260209225402729.png" alt="image-20260209225402729"></p><p>文件路径<code>/home/Qexo-3.3.1/hexoweb/libs/platforms/providers/local.py</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def build(self):</span><br><span class="line">        if not self.auto:</span><br><span class="line">            return False</span><br><span class="line">        # 固定self.auto</span><br><span class="line">        self.auto = [</span><br><span class="line">            [&quot;/root/.nvm/versions/node/v18.0.0/bin/hexo&quot;, &quot;clean&quot;],</span><br><span class="line">            [&quot;/root/.nvm/versions/node/v18.0.0/bin/hexo&quot;, &quot;g&quot;]</span><br><span class="line">        ]</span><br><span class="line">        logging.info(&quot;进行自动部署...&quot;)</span><br><span class="line"></span><br><span class="line">        last_proc = None</span><br><span class="line">        if os.name == &#x27;nt&#x27;:</span><br><span class="line">            exec_cmd = &quot;powershell \&quot;cd &#123;&#125;; &#123;&#125;\&quot;&quot;.format(self.path, self.auto)</span><br><span class="line">        else:</span><br><span class="line">            # exec_cmd = &quot;cd &#123;&#125; &amp;&amp; &#123;&#125;&quot;.format(self.path, self.auto)</span><br><span class="line">            for cmd in self.auto:</span><br><span class="line">                logging.info(&quot;执行命令: %s&quot;, cmd)</span><br><span class="line">                last_proc = subprocess.Popen(</span><br><span class="line">                    cmd,</span><br><span class="line">                    cwd=self.path,</span><br><span class="line">                )</span><br><span class="line">                last_proc.wait()  # 保证顺序执行</span><br><span class="line">            return last_proc</span><br><span class="line">        # logging.info(exec_cmd)</span><br><span class="line">        # p = subprocess.Popen(exec_cmd, shell=True)</span><br><span class="line">        # return p</span><br></pre></td></tr></table></figure><p>修改build函数就行</p><p><img src="/images/qexo/image-20260209231444331.png" alt="image-20260209231444331"></p><p>此时已经完成。根据遇到的问题，很多时候会出现权限问题，修改文件夹权限也能解决</p><h4 id="4、配置图床"><a href="#4、配置图床" class="headerlink" title="4、配置图床"></a>4、配置图床</h4><p><img src="/images/qexo/image-20260202142606153.png" alt="image-20260202142606153"></p><p>图床配置后就可以直接在qexo上面上传图片了。</p><p><img src="/images/qexo/image-20260212150230492.png" alt="image-20260212150230492"></p><p><img src="/images/qexo/image-20260212150249894.png" alt="image-20260212150249894"></p><p>为什么我没有用图床，ikuai的https懒得弄了。所以还是直接使用的github的静态</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建兰空图床</title>
      <link href="/2026/02/09/Docker%E6%90%AD%E5%BB%BA%E5%85%B0%E7%A9%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2026/02/09/Docker%E6%90%AD%E5%BB%BA%E5%85%B0%E7%A9%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>为了博客更好更快的加载，同时减少vercel的流量消耗，图床也是我一直在寻找、追求好用的一个切入点。</p><h5 id="什么是图床？"><a href="#什么是图床？" class="headerlink" title="什么是图床？"></a>什么是图床？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">图床是一种网络服务，它提供了专门用于存储和托管用户上传的图片文件的服务器空间，并且通常允许用户通过获取图片链接的方式将图片嵌入到其他网站或应用中。</span><br><span class="line"></span><br><span class="line">通过将图片上传到图床，用户可以生成一个链接，其他人可以通过这个链接查看或下载该图片。图床通常具有免费和付费版本，提供不同的存储空间和功能选项。</span><br><span class="line"></span><br><span class="line">使用图床的好处是可以方便地将图片分享到各种社交媒体平台、论坛或其他网站上，而无需担心文件大小限制或上传方式的限制。此外，部分图床还提供额外的功能，如图片编辑工具、批量上传、密码保护等，以满足用户的特定需求。</span><br><span class="line"></span><br><span class="line">常见的图床服务有免费和付费两种类型，根据服务质量、存储空间、流量限制以及功能丰富程度各有不同。例如，一些社交媒体平台如微博、B站也可以作为非正式的图床使用，用户上传图片后可以通过修改链接格式引用到其他地方。</span><br><span class="line"></span><br><span class="line">在此值得一提的是，使用微博、B站、QQ等类似平台可能存在较高的图片丢失风险，因此非必要并不建议使用这些平台作为图床</span><br></pre></td></tr></table></figure><h5 id="为什么要用图床？"><a href="#为什么要用图床？" class="headerlink" title="为什么要用图床？"></a>为什么要用图床？</h5><ul><li>减轻主服务器负载：对于个人网站、博客、论坛或其他Web应用程序而言，如果直接在自己的服务器上托管大量图片，可能会增加服务器负担和带宽消耗。通过使用图床，可以将图片资源分离出来，确保文本内容所在的服务器响应更快</li><li>提供稳定快速的图片访问：图床服务商通常会优化图片加载速度，有的还会配备CDN（内容分发网络）来提高全球范围内的访问速度</li><li>方便图片分享和管理：用户无需关心图片存储的技术细节，只需上传图片至图床，即可获取图片链接，然后在任何支持嵌入外部链接的平台上插入图片</li><li>跨平台兼容性：图床链接不受单一平台限制，可以在不同网站、社交平台、邮件等各种环境中共享和展示图片</li></ul><p>目前世面上的图床很多，免费的付费的，付费的第三方图床</p><h4 id="第三方图床"><a href="#第三方图床" class="headerlink" title="第三方图床"></a>第三方图床</h4><h5 id="1、去不图床"><a href="#1、去不图床" class="headerlink" title="1、去不图床"></a>1、去不图床</h5><p>杜老师说<a href="https://dusays.com/%E6%97%97%E4%B8%8B%E7%9A%84%E5%9B%BE%E7%89%87%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%E3%80%82%E6%94%B6%E8%B4%B9%EF%BC%8C%E4%BD%86%E6%9C%8D%E5%8A%A1%E8%BE%83%E7%A8%B3%E5%AE%9A">https://dusays.com/旗下的图片托管平台。收费，但服务较稳定</a></p><p>图床地址：<a href="https://7bu.top/">https://7bu.top/</a></p><p>图床特点</p><ul><li>由杜老师保持维护</li><li>对国内加载速度快</li><li>容量可随用随买</li></ul><h5 id="2、SM-MS图床"><a href="#2、SM-MS图床" class="headerlink" title="2、SM.MS图床"></a>2、SM.MS图床</h5><p>免费图床，目前本站评论区图片上传功能使用此图床中</p><p>主站：<a href="https://sm.ms/">https://sm.ms/</a></p><p>因部分地区存在阻断问题，可能无法打开主站，现已有面向国内的网站<a href="https://smms.app/">https://smms.app/</a></p><p>图床特点</p><ul><li>单个文件最大5M，单次最多上传10张图片</li><li>免费版共5G存储空间（更多内容请查看定价）</li></ul><h4 id="自建图床"><a href="#自建图床" class="headerlink" title="自建图床"></a>自建图床</h4><h5 id="1、Telegraph-Image"><a href="#1、Telegraph-Image" class="headerlink" title="1、Telegraph-Image"></a>1、Telegraph-Image</h5><p>免费图片托管解决方案，是Flickr&#x2F;imgur的替代品，使用Cloudflare Pages和Telegraph作为图床</p><p>项目仓库（github）：<code>https://github.com/cf-pages/Telegraph-Image</code></p><p>具体部署方式可参考该仓库的readme.md文件</p><p>项目特点</p><ul><li>免费，图片数量无限额</li><li>支持后台图片管理</li><li>支持图片审查API</li><li>支持图片白名单加载</li></ul><h5 id="2、Cloudflare-Image-Hosting"><a href="#2、Cloudflare-Image-Hosting" class="headerlink" title="2、Cloudflare Image Hosting"></a>2、Cloudflare Image Hosting</h5><p>Cloudflare图像托管Telegraph上的免费无限图像托管，部署在Cloudflare上</p><p>项目仓库（github）：<code>https://github.com/ifyour/cf-image-hosting</code></p><p>部署方式：</p><p>参考readme</p><p>项目特点：</p><ul><li>免费，图片数量无限额</li><li>可通过拖拽上传图片</li><li>可通过复制粘贴上传图片</li><li>最大文件大小限制为5MB</li><li>可上传图片、gif、视频</li><li>无后台管理</li></ul><h5 id="3、兰空图床"><a href="#3、兰空图床" class="headerlink" title="3、兰空图床"></a>3、兰空图床</h5><p>官网：<code>https://www.lsky.pro/</code></p><p>本文以兰空图床为例搭建：使用docker方式搭建：能使用源码搭建的也能使用源码搭建</p><h5 id="3-1-1-环境"><a href="#3-1-1-环境" class="headerlink" title="3-1.1 环境"></a>3-1.1 环境</h5><p>ubuntu 20.04.6 x64</p><h5 id="3-1-2-安装docker"><a href="#3-1-2-安装docker" class="headerlink" title="3-1.2 安装docker"></a>3-1.2 安装docker</h5><p>直接用按菜鸟教程步骤安装<code>https://www.runoob.com/docker/ubuntu-docker-install.html</code></p><p>如果曾经安装过docker，需要卸载干净</p><h6 id="1、卸载docker"><a href="#1、卸载docker" class="headerlink" title="1、卸载docker"></a>1、卸载docker</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br><span class="line"> </span><br><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h6 id="2、安装docker"><a href="#2、安装docker" class="headerlink" title="2、安装docker"></a>2、安装docker</h6><p>更新apt依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安装apt依赖包，用于通过https来获取仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><p>添加docker官方GPG秘钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc</span><br></pre></td></tr></table></figure><p>再一次更新apt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安装最新docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>重启docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h5 id="3-1-3-安装docker-compose"><a href="#3-1-3-安装docker-compose" class="headerlink" title="3-1.3 安装docker-compose"></a>3-1.3 安装docker-compose</h5><p>根据此项目的docker-compose要求，需要版本是2以上的，因此安装docker-compose 2.37</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/2.37.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>添加权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果发现下载对应的版本下载不下来，可以在&#x2F;etc&#x2F;hosts里面加上本地ping github.com产生的地址，当然可以手动下载后增加</p><p>下载对应的包后，拷贝到&#x2F;usr&#x2F;local&#x2F;bin&#x2F;，并改名为docker-compose，再次执行添加权限命令</p><p><img src="/images/lsky/image-20260131212659011.png" alt="image-20260131212659011"></p><h5 id="3-1-4-修改docker源"><a href="#3-1-4-修改docker源" class="headerlink" title="3-1.4 修改docker源"></a>3-1.4 修改docker源</h5><p>因为网络问题，导致国内的镜像基本都无效，要下载镜像会报错，如图</p><p><img src="/images/lsky/image-20260131212901814.png" alt="image-20260131212901814"></p><p>添加镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>增加次项目中的地址<code>https://github.com/dongyubin/DockerHub</code></p><p><img src="/images/lsky/image-20260131213056498.png" alt="image-20260131213056498"></p><p><img src="/images/lsky/image-20260131213130655.png" alt="image-20260131213130655"></p><h5 id="3-1-5-下载运行镜像"><a href="#3-1-5-下载运行镜像" class="headerlink" title="3-1.5 下载运行镜像"></a>3-1.5 下载运行镜像</h5><p>前置条件已经搞完，接下来开始搭建图床</p><p>创建目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /root/data/docker_data/lsky-pro</span><br><span class="line"></span><br><span class="line">cd /root/data/docker_data/lsky-pro</span><br><span class="line"></span><br><span class="line">nano docker-compose.yml</span><br></pre></td></tr></table></figure><p>docker-compose.yml内容，可以根据自己的要求修改对应的账号密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">    lsky-pro:</span><br><span class="line">        container_name: lsky-pro</span><br><span class="line">        image: dko0/lsky-pro</span><br><span class="line">        restart: always</span><br><span class="line">        volumes:</span><br><span class="line">            - /root/data/docker_data/lsky-pro/lsky-pro-data:/var/www/html  #映射到本地</span><br><span class="line">        ports:</span><br><span class="line">            - 7791:80</span><br><span class="line">        environment:</span><br><span class="line">            - MYSQL_HOST=mysql</span><br><span class="line">            - MYSQL_DATABASE=lsky-pro</span><br><span class="line">            - MYSQL_USER=lsky-pro</span><br><span class="line">            - MYSQL_PASSWORD=lsky-pro</span><br><span class="line"></span><br><span class="line">    mysql:</span><br><span class="line">        image: mysql:8.0</span><br><span class="line">        container_name: lsky-pro-db</span><br><span class="line">        restart: always</span><br><span class="line">        environment:</span><br><span class="line">          - MYSQL_DATABASE=lsky-pro</span><br><span class="line">          - MYSQL_USER=lsky-pro</span><br><span class="line">          - MYSQL_PASSWORD=lsky-pro</span><br><span class="line">          - MYSQL_ROOT_PASSWORD=lsky-pro</span><br><span class="line">        volumes:</span><br><span class="line">          - /root/data/docker_data/lsky-pro/db:/var/lib/mysql</span><br></pre></td></tr></table></figure><p>修改完后，ctrl+x退出，按y保存，enter确认</p><p>运行之前确保7791未被占用，占用请修改或者kill掉使用的进程，运行项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d </span><br></pre></td></tr></table></figure><p><img src="/images/lsky/image-20260131213519459.png" alt="image-20260131213519459"></p><p>运行完后直接浏览器访问当前项目<code>http://127.0.0.1:7791</code></p><h5 id="3-1-6-初始环境"><a href="#3-1-6-初始环境" class="headerlink" title="3-1.6 初始环境"></a>3-1.6 初始环境</h5><p><img src="/images/lsky/image-20260131214339599.png" alt="image-20260131214339599"></p><p>下一步后，数据库连接地址填docker-compose文件里的容器名称lsky-pro-db，连接端口不用填</p><p><img src="/images/lsky/image-20260131214419644.png" alt="image-20260131214419644"></p><p>成功安装</p><p><img src="/images/lsky/image-20260131214404634.png" alt="image-20260131214404634"></p><p><img src="/images/lsky/image-20260131214431125.png" alt="image-20260131214431125"></p><p>一些鸡肋的设置就不说了，自己可以研究下</p><p>直接说最重要的token+接口测试</p><p>获取token</p><p><img src="/images/lsky/image-20260131214953055.png" alt="image-20260131214953055"></p><p><img src="/images/lsky/image-20260131215400581.png" alt="image-20260131215400581"></p><p>可以看到对应的token</p><p>测试上传</p><p><img src="/images/lsky/image-20260131215553822.png" alt="image-20260131215553822"></p><p>正常</p><p>参考：<code>https://blog.laoda.de/archives/docker-compose-install-lskypro</code></p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux搭建emby私人服务器</title>
      <link href="/2024/12/26/emby/"/>
      <url>/2024/12/26/emby/</url>
      
        <content type="html"><![CDATA[<h4 id="Linux搭建emby私人服务器"><a href="#Linux搭建emby私人服务器" class="headerlink" title="Linux搭建emby私人服务器"></a>Linux搭建emby私人服务器</h4><blockquote><p>‌Emby是什么：Emby是一款媒体服务器和媒体中心应用程序，允许用户将他们的媒体文件（如电影、电视节目、音乐等）存储在一个地方，并通过各种设备进行访问和播放。Emby的目标是提供一个流畅、用户友好的媒体管理和播放体验‌。</p><p>优点：<br>1️⃣ 跨平台支持：无论你使用的是 Mac、Windows、Linux、苹果设备、安卓还是智能电视，Emby 都有相应的客户端可供安装，让你在任何设备上都能享受家庭影院。</p><p>2️⃣ 媒体管理：Emby 可以自动抓取影片的元数据，包括海报、剧情简介、演员信息等，让你的影视资源一目了然。</p><p>3️⃣ 用户权限管理：你可以创建多个用户，并为每个用户自定义访问权限，满足不同家庭成员的观影需求。</p><p>4️⃣ 实时转码：Emby 可以根据设备和网络状况实时转码，确保流畅的播放体验。</p></blockquote><h5 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h5><p>官网：<code>https://emby.media/</code></p><p>本文以debain系统为例，搭建一个emby服务器并上传视频观看</p><p>教程：<code>https://emby.media/linux-server.html</code></p><p>简单2步，就能构建一个emby服务，因为下载太慢，本文手动下载后安装</p><p><img src="/images/emby/image-20241210192956945.png" alt="image-20241210192956945"></p><p><img src="/images/emby/image-20241210193109089.png" alt="image-20241210193109089"></p><h5 id="2、简单设置"><a href="#2、简单设置" class="headerlink" title="2、简单设置"></a>2、简单设置</h5><p><img src="/images/emby/image-20241210193527305.png" alt="image-20241210193527305"></p><p><img src="/images/emby/image-20241210193611809.png" alt="image-20241210193611809"></p><p>后续一直默认就好，安装完成添加对应的影片，在emby输入地址就能正常访问。</p><p>以我们自己搭建的服务器为例：</p><p><img src="/images/emby/image-20260208231745952.png" alt="image-20260208231745952"></p><p>连接后添加对应的账号就行</p><p><img src="/images/emby/image-20260208231825900.png" alt="image-20260208231825900"> </p><p>我们自己的片库大致是这样，感兴趣的可以试试,有需要可以淘宝扫码查看<br><img src="/img/emby.png" alt="emby"></p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建私有的个人远程RustDesk</title>
      <link href="/2024/12/07/RustDesk/"/>
      <url>/2024/12/07/RustDesk/</url>
      
        <content type="html"><![CDATA[<h4 id="在Linux服务器搭建RustDesk远程"><a href="#在Linux服务器搭建RustDesk远程" class="headerlink" title="在Linux服务器搭建RustDesk远程"></a>在Linux服务器搭建RustDesk远程</h4><blockquote><p>为什么搭建RustDesk，市面上的Todesk、向日葵不能使用吗？</p><p>PC端自用，使用Todesk和向日葵确实能满足需求，但是涉及到移动设备的远控时，免费的Todesk、向日葵不支持移动设备远控，同时在PC远控也有诸多限制，而今天介绍到的RustDesk完全没有这些限制，支持多平台（Linux、Windows、macOS、Android）</p></blockquote><span id="more"></span><blockquote><p>前置条件：一台公网ip的Linux云服务器</p></blockquote><p><img src="/images/RustDesk/image-20241207144634301.png" alt="image-20241207144634301"></p><p><img src="/images/RustDesk/image-20241207144712331.png" alt="image-20241207144712331"></p><h5 id="1、搭建"><a href="#1、搭建" class="headerlink" title="1、搭建"></a>1、搭建</h5><blockquote><p>本教程基于Linux（centos）、在宝塔上安装RustDesk服务</p><p>项目地址：<code>https://github.com/rustdesk/rustdesk-server/releases/</code></p></blockquote><p>根据服务器版本下载对应的源码版本，因为我的是x86的，下载linux-amd64就好</p><p><img src="/images/RustDesk/image-20241207145705493.png" alt="image-20241207145705493"></p><p><img src="/images/RustDesk/image-20241207145608431.png" alt="image-20241207145608431"></p><ul><li>1、安装宝塔：<code>https://www.bt.cn/new/download.html</code></li></ul><p>CentOS安装宝塔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=https://download.bt.cn/install/install_lts.sh;if [ -f /usr/bin/curl ];then curl -sSO $url;else wget -O install_lts.sh $url;fi;bash install_lts.sh ed8484bec</span><br></pre></td></tr></table></figure><p><img src="/images/RustDesk/image-20241207150305917.png" alt="image-20241207150305917"></p><p>安装完成根据生成的外网地址或者内网地址登录宝塔，此时如果登录不了，请在服务器防火墙放通对应的端口，本例为：35011</p><p>第一次登录需要注册一个宝塔账号，注册后登录，如下图所示：</p><p><img src="/images/RustDesk/image-20241207150559196.png" alt="image-20241207150559196"></p><ul><li>2、配置RustDesk服务</li></ul><p><img src="/images/RustDesk/image-20241207150749818.png" alt="image-20241207150749818"></p><p>点击文件，选择你喜欢的文件夹创建rustdesk文件，本例为www下</p><p><img src="/images/RustDesk/image-20241207151238636.png" alt="image-20241207151238636"></p><p><img src="/images/RustDesk/image-20241207151306473.png" alt="image-20241207151306473"></p><p>解压文件，可以看到最后就三个文件</p><p><img src="/images/RustDesk/image-20241207151401238.png" alt="image-20241207151401238"></p><p>因为我们需要rustdesk服务时刻运行，并能自动重启，那么需要搞一个守护程序。软件商店搜索：进程守护 安装</p><p><img src="/images/RustDesk/image-20241207151620540.png" alt="image-20241207151620540"></p><p>添加守护程序，点击设置-&gt; 添加守护程序 -&gt; 确认</p><p><img src="/images/RustDesk/image-20241207151734249.png" alt="image-20241207151734249"></p><p>目录和启动命令以我的为例：</p><p><img src="/images/RustDesk/image-20241207152041447.png" alt="image-20241207152041447"></p><p><img src="/images/RustDesk/image-20241207152057817.png" alt="image-20241207152057817"></p><p>守护程序设置好后，状态为Running时为正常</p><p><img src="/images/RustDesk/image-20241207152314070.png" alt="image-20241207152314070"></p><p>在文件列表中会生成一些文件，记住id_xx.pub里面为中继器的key，保存好后续使用</p><p><img src="/images/RustDesk/image-20241207161233449.png" alt="image-20241207161233449"></p><p>端口放通：你需要放通21116 - TCP&#x2F;UDP、21117 - TCP</p><p>如图在安全中添加，当然在你的服务器安全组也需要放通</p><p><img src="/images/RustDesk/image-20241207161445650.png" alt="image-20241207161445650"></p><h5 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h5><p>在软件中输入刚才对应的id和中继服务器以及key，主页状态为就绪说明已经成功，之后找两台设备使用即可</p><p><img src="/images/RustDesk/image-20241207161726741.png" alt="image-20241207161726741"></p><p><img src="/images/RustDesk/image-20241207161830887.png" alt="image-20241207161830887"></p>]]></content>
      
      
      <categories>
          
          <category> 瞎折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RustDesk </tag>
            
            <tag> 远程协助 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mimiciv医疗数据库安装（derived衍生表）</title>
      <link href="/2024/12/06/postgresql03/"/>
      <url>/2024/12/06/postgresql03/</url>
      
        <content type="html"><![CDATA[<h4 id="windows安装mimic医疗数据库衍生表derived"><a href="#windows安装mimic医疗数据库衍生表derived" class="headerlink" title="windows安装mimic医疗数据库衍生表derived"></a>windows安装mimic医疗数据库衍生表derived</h4><p>前置条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装git（全部默认安装即可）：下载地址 https://git-scm.com/downloads</span><br></pre></td></tr></table></figure><span id="more"></span><p>紧接上回、已经安装完了icu和hosp数据，现在生成衍生表</p><p>衍生表sql路径<code>D:\mimic-code-main\mimic-iv\concepts_postgres</code></p><p><img src="/images/postgresql03/image-20241206193638730.png" alt="image-20241206193638730"></p><h5 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h5><ul><li>设置路径</li></ul><p><img src="/images/postgresql03/image-20241206193843842.png" alt="image-20241206193843842"></p><ul><li><p>执行postgres-functions.sql生成对应的方法<code>\i D:/mimic-code-main/mimic-iv/concepts_postgres/postgres-functions.sql</code></p><p><img src="/images/postgresql03/image-20241206194003957.png" alt="image-20241206194003957"></p></li><li><p>执行shell生成衍生表格数据文件夹postgres</p></li></ul><p><img src="/images/postgresql03/image-20241206194622743.png" alt="image-20241206194622743"></p><p><img src="/images/postgresql03/image-20241206194818354.png" alt="image-20241206194818354"></p><ul><li>生成衍生表格数据<ul><li>修改postgres-make-concepts.sql</li></ul></li></ul><p><img src="/images/postgresql03/image-20241206195056707.png" alt="image-20241206195056707"></p><ul><li>执行</li></ul><p><img src="/images/postgresql03/image-20241206195813987.png" alt="image-20241206195813987"></p><p>之后就是漫长的等待，直到结束就好。</p><p>小店提供安装服务，有需要可以淘宝扫码查看</p><p><img src="/img/pgsql.png" alt="pgsql"></p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
            <tag> MIMIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mimiciv医疗数据库安装（icu+hosp）</title>
      <link href="/2024/12/05/postgresql02/"/>
      <url>/2024/12/05/postgresql02/</url>
      
        <content type="html"><![CDATA[<h4 id="windows安装mimic医疗数据库"><a href="#windows安装mimic医疗数据库" class="headerlink" title="windows安装mimic医疗数据库"></a>windows安装mimic医疗数据库</h4><h5 id="注意：mimic需要硬盘空间120G左右，请预留足够的空间"><a href="#注意：mimic需要硬盘空间120G左右，请预留足够的空间" class="headerlink" title="注意：mimic需要硬盘空间120G左右，请预留足够的空间"></a>注意：mimic需要硬盘空间120G左右，请预留足够的空间</h5><p>前置条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、安装7z</span><br><span class="line">2、安装postgresql</span><br><span class="line">3、mimic数据包 https://physionet.org/content/mimiciv/2.2/</span><br><span class="line">4、mimic数据生成包：https://github.com/MIT-LCP/mimic-code</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h5><p>以mimiciv2.2为例，请确保前置条件已经搞好。</p><p>在D盘创建一个数据根目录MIMIC，用于后续的设置，我是直接将相关的数据都放入了MIMIC</p><p><img src="/images/postgresql02/image-20241205200313591.png" alt="image-20241205200313591"></p><p>登录到pgsql的shell中</p><p><img src="/images/postgresql02/image-20241205153150243.png" alt="image-20241205153150243"></p><p><img src="/images/postgresql02/image-20241205153223718.png" alt="image-20241205153223718"></p><h5 id="2、安装命令"><a href="#2、安装命令" class="headerlink" title="2、安装命令"></a>2、安装命令</h5><ul><li>1、创建数据库</li></ul><p>Drop database if exists mimiciv;</p><p>create database mimiciv owner postgres;</p><p><img src="/images/postgresql02/image-20241205154720915.png" alt="image-20241205154720915"></p><ul><li>设置默认目录与编码</li></ul><p><img src="/images/postgresql02/image-20241205154907509.png" alt="image-20241205154907509"></p><p>在命令行依次执行create、load_7z、constraint、index.sql文件</p><p><img src="/images/postgresql02/image-20241205170955572.png" alt="image-20241205170955572"></p><p>若出现permission deny，将所有的”&quot;替换成 “&#x2F;“</p><p><img src="/images/postgresql02/image-20241205171222144.png" alt="image-20241205171222144"></p><p>执行到load_7z.sql导入数据、根据电脑性能，会等待1-2个小时 <code>\i D:/MIMIC/load_7z.sql</code></p><p><img src="/images/postgresql02/image-20241205200140882.png" alt="image-20241205200140882"></p><p>执行<code>\i D:/MIMIC/constraint.sql</code>创建主键</p><p><img src="/images/postgresql02/image-20241206142203677.png" alt="image-20241206142203677"></p><p>执行<code>\i D:/MIMIC/index.sql</code>创建索引</p><p><img src="/images/postgresql02/image-20241206151808889.png" alt="image-20241206151808889"></p><h5 id="3、查看"><a href="#3、查看" class="headerlink" title="3、查看"></a>3、查看</h5><p>hosp</p><p><img src="/images/postgresql02/image-20241206181931467.png" alt="image-20241206181931467"></p><p>icu</p><p><img src="/images/postgresql02/image-20241206181948265.png" alt="image-20241206181948265"></p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
            <tag> MIMIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgresql安装</title>
      <link href="/2024/12/04/postgresql01/"/>
      <url>/2024/12/04/postgresql01/</url>
      
        <content type="html"><![CDATA[<h4 id="沉浸式安装postgresql-windows版"><a href="#沉浸式安装postgresql-windows版" class="headerlink" title="沉浸式安装postgresql-windows版"></a>沉浸式安装postgresql-windows版</h4><h5 id="注意：pgsql对路径严格要求、安装路径不能存在中文，否则会报错"><a href="#注意：pgsql对路径严格要求、安装路径不能存在中文，否则会报错" class="headerlink" title="注意：pgsql对路径严格要求、安装路径不能存在中文，否则会报错"></a>注意：pgsql对路径严格要求、安装路径不能存在中文，否则会报错</h5><span id="more"></span><h5 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h5><p><code>https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</code></p><p>在下载页面下载你需要版本的pgsql安装包</p><h5 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h5><p><img src="/images/postgresql01/image-20241204155029168.png" alt="image-20241204155029168"></p><p><img src="/images/postgresql01/image-20241204155126233.png" alt="image-20241204155126233"></p><p><img src="/images/postgresql01/image-20241204155203948.png" alt="image-20241204155203948"></p><p><img src="/images/postgresql01/image-20241204155219197.png" alt="image-20241204155219197"></p><p><img src="/images/postgresql01/image-20241204155403455.png" alt="image-20241204155403455"></p><p><img src="/images/postgresql01/image-20241204155333693.png" alt="image-20241204155333693"></p><p><img src="/images/postgresql01/image-20241204155419481.png" alt="image-20241204155419481"></p><p><img src="/images/postgresql01/image-20241204155434572.png" alt="image-20241204155434572"></p><p><img src="/images/postgresql01/image-20241204155447005.png" alt="image-20241204155447005"></p><p>next之后就开始等待吧，结束后直接finish，然后取消Stack Builder就好</p><p><img src="/images/postgresql01/image-20241204161353769.png" alt="image-20241204161353769"></p><p>到此，windows的pgsql安装已经完成。简单测试下</p><p><img src="/images/postgresql01/image-20241204164335658.png" alt="image-20241204164335658"></p><h5 id="3、演示只是在完全正常的情况下，安装pgsql会出现各种各样的报错，这个我们后续慢慢道来。"><a href="#3、演示只是在完全正常的情况下，安装pgsql会出现各种各样的报错，这个我们后续慢慢道来。" class="headerlink" title="3、演示只是在完全正常的情况下，安装pgsql会出现各种各样的报错，这个我们后续慢慢道来。"></a>3、演示只是在完全正常的情况下，安装pgsql会出现各种各样的报错，这个我们后续慢慢道来。</h5>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建</title>
      <link href="/2024/11/26/hexo01/"/>
      <url>/2024/11/26/hexo01/</url>
      
        <content type="html"><![CDATA[<p> 网址：tuhou.github.io</p><p>从搭建hexo到发布到github，以及简单的优化</p><p>简单介绍hexo：Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><span id="more"></span><p>依赖：本文以ubuntu为例，需要安装node和git</p><h5 id="1、node安装："><a href="#1、node安装：" class="headerlink" title="1、node安装："></a>1、node安装：</h5><p>下载地址：<code>https://nodejs.cn/download/</code></p><p><img src="/images/hexo01/image-20241126214015683.png" alt="image-20241126214015683"></p><p>下载对应的版本双击安装</p><p>安装完成后：创建对应的软链接</p><p><code>ln -s /home/node/（你的安装目录） /usr/local/bin</code></p><p><code>ln -s /home/npm/（你的安装目录） /usr/local/bin</code></p><h5 id="2、安装git"><a href="#2、安装git" class="headerlink" title="2、安装git"></a>2、安装git</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>此时需注意：使用npm的时候可能会报错，此处需要设置npm的源，因为淘宝源已经过期，那么当前将其设置为新的。</p><p><code>npm config set registry https://registry.npmmirror.com/</code></p><h5 id="3、安装hexo"><a href="#3、安装hexo" class="headerlink" title="3、安装hexo"></a>3、安装hexo</h5><p><code>npm install -g hexo-cli</code></p><p>此文章以我的目录为例，创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/blog</span><br><span class="line">cd /home/blog</span><br></pre></td></tr></table></figure><p>hexo初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">hexo g</span><br><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><p>此时，你可以看到本地<code>http://localhost:4000</code>就能看到对应的网站了</p><p><img src="/images/hexo01/image-20241126222900783.png" alt="image-20241126222900783"></p><p>当然安装hexo并不是我们的最终目的，我们要将hexo上传到github，并生成一个github的网站</p><h5 id="4、github端设置"><a href="#4、github端设置" class="headerlink" title="4、github端设置"></a>4、github端设置</h5><p>1、github端创建一个公共的仓库，注意名称命名为 xxx.github.io必须的（xxx设置为你自己想设置的），确认就好</p><p><img src="/images/hexo01/image-20241126230358114.png" alt="image-20241126230358114"></p><p>2、在服务器上，配置本地用户信息</p><ul><li>使用 <code>git config --global user.name &quot;name&quot; </code>配置本地用户信息，name为你的git账户名</li><li>使用 <code>git config --global user.email &quot;xxx@xx.com&quot;</code>配置本地邮箱，email为你git账户邮箱</li><li>使用  <code>ssh-keygen -t rsa -C&quot;xxx@xx.com&quot;</code> 命令生成本地私钥和密钥信息，需要输入yes是输入y<ul><li>秘钥生成后，在本地<code>~/.ssh</code>，在此路径上找到git的密码文件 id_rsa.pub</li></ul></li></ul><p>3、进行git与github的授权认证</p><ul><li>在github设置页面，选择左侧<code>ssh and GPG keys</code> 名称随意，key为id_rsa.pub添加</li></ul><p><img src="/images/hexo01/image-20241127002414324.png" alt="image-20241127002414324"></p><p><img src="/images/hexo01/image-20241127002456565.png" alt="image-20241127002456565"></p><p>此时回到服务器，命令行输入<code>ssh -T git@github.com</code>检查可以与远程进行统信，会出现Hi …说明授权成功</p><p>4、以为目前github已经不支持密码授权，所以下载需要搞一个token： settings -&gt; Developer settings</p><p><img src="/images/hexo01/image-20241127003406845.png" alt="image-20241127003406845"></p><p>创建后记得记住，因为只展示一次</p><p>5、在hexo的主配置文件_config.yml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/tuhou/tuhou.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="/images/hexo01/image-20241127003603610.png" alt="image-20241127003603610"></p><h5 id="5、文章上线到github"><a href="#5、文章上线到github" class="headerlink" title="5、文章上线到github"></a>5、文章上线到github</h5><p>会让你输入名称和token，可以看到已经有了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><img src="/images/hexo01/image-20241127003823703.png" alt="image-20241127003823703"></p><p><img src="/images/hexo01/image-20241127004215902.png" alt="image-20241127004215902"></p><p>后续的美化暂时停下，等后续再聊</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
